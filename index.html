<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Three.js Car - Optimized</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
    canvas { display: block; }
    #info { 
      position: absolute; top: 10px; left: 10px; 
      color: white; background: rgba(0,0,0,0.7); 
      padding: 15px; border-radius: 5px; font-size: 14px; 
    }
  </style>
</head>
<body>
  <div id="info">
    <strong>Controls:</strong><br>
    W/↑ - Forward<br>
    S/↓ - Backward<br>
    A/← - Steer Left<br>
    D/→ - Steer Right
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000520);
    scene.fog = new THREE.Fog(0x000520, 30, 100);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 15, 10);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // Lighting
    scene.add(new THREE.AmbientLight(0xffffff, 0.15));
    
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.25);
    dirLight.position.set(10, 20, 10);
    dirLight.castShadow = true;
    Object.assign(dirLight.shadow.camera, { left: -50, right: 50, top: 50, bottom: -50 });
    scene.add(dirLight);

    // Infinite floor with grid shader
    const floorMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uCameraPos: { value: new THREE.Vector3() },
        uGridSize: { value: 10.0 },
        uGridColor: { value: new THREE.Color(0xaaaaaa) },
        uGroundColor: { value: new THREE.Color(0x1a4d1a) }
      },
      vertexShader: `
        varying vec3 vWorldPosition;
        void main() {
          vec4 worldPosition = modelMatrix * vec4(position, 1.0);
          vWorldPosition = worldPosition.xyz;
          gl_Position = projectionMatrix * viewMatrix * worldPosition;
        }
      `,
      fragmentShader: `
        uniform vec3 uCameraPos;
        uniform float uGridSize;
        uniform vec3 uGridColor;
        uniform vec3 uGroundColor;
        varying vec3 vWorldPosition;

        void main() {
          vec2 coord = vWorldPosition.xz;
          vec2 grid = abs(fract(coord / uGridSize - 0.5) - 0.5) / fwidth(coord / uGridSize);
          float line = min(grid.x, grid.y);
          float gridStrength = 1.0 - min(line, 1.0);
          
          float dist = length(vWorldPosition.xz - uCameraPos.xz);
          float fadeFactor = 1.0 - smoothstep(80.0, 200.0, dist);
          gridStrength *= fadeFactor;
          
          vec3 color = mix(uGroundColor, uGridColor, gridStrength * 0.7);
          gl_FragColor = vec4(color, 1.0);
        }
      `,
      side: THREE.DoubleSide
    });

    const ground = new THREE.Mesh(new THREE.PlaneGeometry(500, 500, 1, 1), floorMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Car assembly
    const car = new THREE.Group();

    // Helper to create mesh with shadow
    const createMesh = (geometry, color, castShadow = true) => {
      const mesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ color }));
      mesh.castShadow = castShadow;
      return mesh;
    };

    // Body and cabin
    const body = createMesh(new THREE.BoxGeometry(2, 0.8, 3), 0xff4444);
    body.position.y = 0.7;
    car.add(body);

    const cabin = createMesh(new THREE.BoxGeometry(1.6, 0.8, 1.8), 0x444444);
    cabin.position.set(0, 1.3, -0.2);
    car.add(cabin);

    // Wheels
    const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 16);
    const wheelPositions = [[-1, 0.4, 1], [1, 0.4, 1], [-1, 0.4, -1], [1, 0.4, -1]];
    const wheels = wheelPositions.map(pos => {
      const wheel = createMesh(wheelGeometry, 0x222222);
      wheel.rotation.z = Math.PI / 2;
      wheel.position.set(...pos);
      car.add(wheel);
      return wheel;
    });

    // Headlight beam shader
    const beamMaterial = new THREE.ShaderMaterial({
      vertexShader: `
        varying vec2 vUv;
        varying vec3 vPosition;
        void main() {
          vUv = uv;
          vPosition = position;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        varying vec2 vUv;
        varying vec3 vPosition;
        void main() {
          float distFromCenter = length(vUv - vec2(0.5)) * 2.0;
          float normalizedPos = (vPosition.y + 2.0) / 4.0;
          float lengthFade = pow(1.0 - normalizedPos, 0.7);
          float alpha = smoothstep(0.0, 1.0, (1.0 - distFromCenter) * lengthFade);
          gl_FragColor = vec4(vec3(0.7, 0.7, 0.45), pow(alpha, 2.0) * 0.25);
        }
      `,
      transparent: true,
      side: THREE.DoubleSide,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });

    // Light beams, bulbs, and spotlights
    const beamGeometry = new THREE.CylinderGeometry(2.8, 0.05, 4, 32, 1, true);
    const lightConfig = [
      { x: -0.7, beamPos: [0.6, 3.5], targetZ: 6 },
      { x: 0.7, beamPos: [0.6, 3.5], targetZ: 6 }
    ];

    lightConfig.forEach(({ x, beamPos, targetZ }) => {
      // Beam
      const beam = new THREE.Mesh(beamGeometry, beamMaterial);
      beam.position.set(x, ...beamPos);
      beam.rotation.x = Math.PI / 2;
      car.add(beam);

      // Bulb
      const bulb = new THREE.Mesh(
        new THREE.SphereGeometry(0.2, 16, 16),
        new THREE.MeshBasicMaterial({ color: 0xaaaa44 })
      );
      bulb.position.set(x, 0.6, 1.5);
      car.add(bulb);

      // Point light
      const pointLight = new THREE.PointLight(0xaaaa88, 1, 4);
      pointLight.position.copy(bulb.position);
      car.add(pointLight);

      // Spotlight
      const spotLight = new THREE.SpotLight(0xaaaa88, 2.0, 8, Math.PI / 6, 0.3, 1.5);
      spotLight.position.copy(bulb.position);
      spotLight.castShadow = true;
      spotLight.shadow.mapSize.setScalar(1024);
      
      const target = new THREE.Object3D();
      target.position.set(x, 0, targetZ);
      car.add(target);
      spotLight.target = target;
      car.add(spotLight);
    });

    scene.add(car);

    // Trail system
    const trails = [
      { points: [], mesh: null, geometry: null, offset: new THREE.Vector3(-1, 0.05, -1) },
      { points: [], mesh: null, geometry: null, offset: new THREE.Vector3(1, 0.05, -1) }
    ];
    const maxTrailPoints = 40;
    let frameCounter = 0;

    const updateTrail = () => {
      frameCounter++;
      if (frameCounter % 1 === 0 && Math.abs(currentSpeed) > 0.001) {
        car.updateMatrixWorld();
        
        trails.forEach(trail => {
          const worldPos = trail.offset.clone().applyMatrix4(car.matrixWorld);
          trail.points.push(worldPos);
          if (trail.points.length > maxTrailPoints) trail.points.shift();
          
          if (trail.points.length > 1) {
            if (trail.mesh) {
              scene.remove(trail.mesh);
              trail.geometry?.dispose();
            }
            
            const curve = new THREE.CatmullRomCurve3(trail.points);
            trail.geometry = new THREE.TubeGeometry(curve, trail.points.length * 2, 0.2, 8, false);
            trail.mesh = new THREE.Mesh(
              trail.geometry,
              new THREE.MeshBasicMaterial({ color: 0x111111, side: THREE.DoubleSide })
            );
            scene.add(trail.mesh);
          }
        });
      }
    };

    // Controls
    const keys = {};
    ['keydown', 'keyup'].forEach(event => {
      document.addEventListener(event, e => {
        const key = e.key.toLowerCase();
        keys[key] = keys[e.key] = (event === 'keydown');
      });
    });

    // Physics constants
    const physics = {
      acceleration: 0.008,
      maxSpeed: 0.25,
      friction: 0.96,
      maxSteerAngle: 0.6,
      steerSpeed: 0.08,
      wheelBase: 2
    };
    let steerAngle = 0, currentSpeed = 0;

    const updateCar = () => {
      // Steering
      let targetSteerAngle = 0;
      if (keys.a || keys.arrowleft) targetSteerAngle = physics.maxSteerAngle;
      else if (keys.d || keys.arrowright) targetSteerAngle = -physics.maxSteerAngle;
      
      steerAngle += (targetSteerAngle - steerAngle) * physics.steerSpeed;
      wheels[0].rotation.y = wheels[1].rotation.y = steerAngle;

      // Acceleration
      let targetAcceleration = 0;
      if (keys.w || keys.arrowup) targetAcceleration = physics.acceleration;
      else if (keys.s || keys.arrowdown) targetAcceleration = -physics.acceleration;

      currentSpeed += targetAcceleration;
      currentSpeed *= physics.friction;
      currentSpeed = Math.max(-physics.maxSpeed, Math.min(physics.maxSpeed, currentSpeed));
      if (Math.abs(currentSpeed) < 0.001) currentSpeed = 0;

      // Movement
      if (Math.abs(currentSpeed) > 0.001) {
        if (Math.abs(steerAngle) > 0.01) {
          const turningRadius = physics.wheelBase / Math.tan(Math.abs(steerAngle));
          const angularVelocity = currentSpeed / turningRadius;
          car.rotation.y += Math.sign(steerAngle) * angularVelocity;
        }
        car.position.x += Math.sin(car.rotation.y) * currentSpeed;
        car.position.z += Math.cos(car.rotation.y) * currentSpeed;
      }

      // Camera follows car
      camera.position.x = car.position.x;
      camera.position.z = car.position.z + 10;
      camera.lookAt(car.position);

      // Update floor and light positions
      ground.position.set(car.position.x, 0, car.position.z);
      floorMaterial.uniforms.uCameraPos.value.copy(camera.position);
      
      dirLight.position.set(car.position.x + 10, 20, car.position.z + 10);
      dirLight.target.position.copy(car.position);
      dirLight.target.updateMatrixWorld();
    };

    // Resize handler
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Animation loop
    const animate = () => {
      requestAnimationFrame(animate);
      updateCar();
      updateTrail();
      renderer.render(scene, camera);
    };

    animate();
  </script>
</body>
</html>
